---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Image Classifier">
	<div class="app">
		<header class="header">
			<div class="container">
				<h1 class="logo">Image Classifier</h1>
				<div class="status-badge" id="statusBadge">Ready</div>
			</div>
		</header>

		<main class="main">
			<div class="container">
				<!-- Step 1: Upload Dataset -->
				<section class="card">
					<div class="card-header">
						<div class="step-number">1</div>
						<div>
							<h2>Upload Training Data</h2>
							<p>Drag & drop folder or select files</p>
						</div>
					</div>
					
					<div class="upload-zone" id="uploadZone">
						<svg class="upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor">
							<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" stroke-width="2"/>
						</svg>
						<h3>Drag & Drop Folder Here</h3>
						<p class="text-muted">or click to select files</p>
						<p class="help-text">Organize: MyData/duit5000/img1.jpg, MyData/duit10000/img2.jpg</p>
						<input type="file" id="fileInput" multiple accept="image/*" hidden/>
					</div>

					<div class="dataset-summary" id="datasetSummary" style="display: none;">
						<div class="summary-grid">
							<div class="summary-item">
								<div class="summary-label">Total Images</div>
								<div class="summary-value" id="totalImages">0</div>
							</div>
							<div class="summary-item">
								<div class="summary-label">Classes</div>
								<div class="summary-value" id="totalClasses">0</div>
							</div>
						</div>
						<div class="class-tags" id="classTags"></div>
						<button class="btn-primary" id="startTrainBtn">Start Training</button>
					</div>
				</section>

				<!-- Step 2: Training Progress -->
				<section class="card" id="trainSection" style="display: none;">
					<div class="card-header">
						<div class="step-number">2</div>
						<div>
							<h2>Training Progress</h2>
							<p>Model is being trained</p>
						</div>
					</div>

					<div class="progress-section">
						<div class="progress-bar">
							<div class="progress-fill" id="progressFill"></div>
						</div>
						<div class="progress-info">
							<span id="progressText">Training...</span>
							<span id="progressPercent">0%</span>
						</div>
					</div>
				</section>

				<!-- Step 3: Test Model -->
				<section class="card" id="testSection" style="display: none;">
					<div class="card-header">
						<div class="step-number">3</div>
						<div>
							<h2>Test Your Model</h2>
							<p>Upload an image to classify</p>
						</div>
					</div>

					<div class="test-container">
						<div class="test-upload" id="testUpload">
							<svg class="upload-icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor">
								<rect x="3" y="3" width="18" height="18" rx="2" stroke-width="2"/>
								<circle cx="8.5" cy="8.5" r="1.5"/>
								<path d="M21 15l-5-5L5 21" stroke-width="2"/>
							</svg>
							<p>Click to upload test image</p>
							<input type="file" id="testInput" accept="image/*" hidden/>
						</div>

						<div class="test-result" id="testResult" style="display: none;">
							<img id="testImage" alt="Test"/>
							<div class="result-content">
								<div class="result-class" id="resultClass"></div>
								<div class="result-confidence">
									<div class="confidence-bar">
										<div class="confidence-fill" id="confidenceFill"></div>
									</div>
									<span id="confidenceText"></span>
								</div>
								<div class="all-predictions" id="allPredictions"></div>
							</div>
						</div>
					</div>
				</section>
			</div>
		</main>
	</div>
</Layout>

<style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
	}

	:root {
		--bg: #0a0a0a;
		--surface: #1a1a1a;
		--border: #2a2a2a;
		--text: #ffffff;
		--text-muted: #888888;
		--primary: #0066ff;
		--primary-hover: #0052cc;
		--success: #00ff88;
		--radius: 16px;
	}

	body {
		background: var(--bg);
		color: var(--text);
		font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
		line-height: 1.6;
	}

	.app {
		min-height: 100vh;
	}

	.header {
		background: rgba(26, 26, 26, 0.8);
		border-bottom: 1px solid var(--border);
		padding: 20px 0;
		position: sticky;
		top: 0;
		z-index: 100;
		backdrop-filter: blur(20px);
	}

	.container {
		max-width: 1200px;
		margin: 0 auto;
		padding: 0 24px;
	}

	.header .container {
		display: flex;
		justify-content: space-between;
		align-items: center;
	}

	.logo {
		font-size: 20px;
		font-weight: 600;
		letter-spacing: -0.5px;
	}

	.status-badge {
		background: var(--surface);
		border: 1px solid var(--border);
		padding: 6px 16px;
		border-radius: 20px;
		font-size: 14px;
		color: var(--success);
	}

	.main {
		padding: 48px 0;
	}

	.card {
		background: var(--surface);
		border: 1px solid var(--border);
		border-radius: var(--radius);
		padding: 32px;
		margin-bottom: 24px;
	}

	.card-header {
		display: flex;
		gap: 20px;
		margin-bottom: 32px;
	}

	.step-number {
		width: 48px;
		height: 48px;
		background: var(--primary);
		border-radius: 50%;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 20px;
		font-weight: 700;
		flex-shrink: 0;
	}

	.card-header h2 {
		font-size: 24px;
		font-weight: 600;
		margin-bottom: 4px;
	}

	.card-header p {
		color: var(--text-muted);
		font-size: 14px;
	}

	.upload-zone {
		border: 2px dashed var(--border);
		border-radius: var(--radius);
		padding: 64px 32px;
		text-align: center;
		cursor: pointer;
		transition: all 0.3s;
	}

	.upload-zone:hover, .upload-zone.drag-over {
		border-color: var(--primary);
		background: rgba(0, 102, 255, 0.05);
	}

	.upload-icon {
		width: 64px;
		height: 64px;
		margin: 0 auto 20px;
		color: var(--text-muted);
	}

	.upload-zone h3 {
		font-size: 18px;
		margin-bottom: 8px;
	}

	.text-muted {
		color: var(--text-muted);
		font-size: 14px;
	}

	.help-text {
		font-size: 12px;
		color: var(--text-muted);
		margin-top: 8px;
		opacity: 0.7;
	}

	.dataset-summary {
		margin-top: 24px;
		padding-top: 24px;
		border-top: 1px solid var(--border);
	}

	.summary-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
		gap: 16px;
		margin-bottom: 24px;
	}

	.summary-item {
		background: var(--bg);
		padding: 20px;
		border-radius: 12px;
		text-align: center;
	}

	.summary-label {
		font-size: 12px;
		color: var(--text-muted);
		text-transform: uppercase;
		letter-spacing: 1px;
		margin-bottom: 8px;
	}

	.summary-value {
		font-size: 32px;
		font-weight: 700;
		color: var(--primary);
	}

	.class-tags {
		display: flex;
		flex-wrap: wrap;
		gap: 8px;
		margin-bottom: 24px;
	}

	.class-tag {
		background: var(--bg);
		padding: 12px 20px;
		border-radius: 20px;
		font-size: 14px;
		border: 1px solid var(--border);
	}

	.class-tag strong {
		color: var(--primary);
		margin-right: 8px;
	}

	.btn-primary {
		background: var(--primary);
		color: white;
		border: none;
		padding: 16px 40px;
		border-radius: 8px;
		font-size: 16px;
		font-weight: 600;
		cursor: pointer;
		transition: all 0.2s;
		width: 100%;
	}

	.btn-primary:hover:not(:disabled) {
		background: var(--primary-hover);
		transform: translateY(-1px);
	}

	.btn-primary:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.progress-section {
		margin-top: 24px;
	}

	.progress-bar {
		height: 8px;
		background: var(--bg);
		border-radius: 4px;
		overflow: hidden;
		margin-bottom: 12px;
	}

	.progress-fill {
		height: 100%;
		background: linear-gradient(90deg, var(--primary), var(--success));
		transition: width 0.3s;
		width: 0%;
	}

	.progress-info {
		display: flex;
		justify-content: space-between;
		font-size: 14px;
		color: var(--text-muted);
	}

	.test-container {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 24px;
	}

	.test-upload {
		border: 2px dashed var(--border);
		border-radius: var(--radius);
		padding: 48px 24px;
		text-align: center;
		cursor: pointer;
		transition: all 0.3s;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		min-height: 400px;
	}

	.test-upload:hover {
		border-color: var(--primary);
		background: rgba(0, 102, 255, 0.05);
	}

	.upload-icon-sm {
		width: 48px;
		height: 48px;
		color: var(--text-muted);
		margin-bottom: 16px;
	}

	.test-result {
		border-radius: var(--radius);
		overflow: hidden;
		background: var(--bg);
		border: 1px solid var(--border);
	}

	.test-result img {
		width: 100%;
		height: 300px;
		object-fit: cover;
	}

	.result-content {
		padding: 24px;
	}

	.result-class {
		font-size: 32px;
		font-weight: 700;
		margin-bottom: 16px;
		color: var(--success);
	}

	.confidence-bar {
		height: 8px;
		background: var(--surface);
		border-radius: 4px;
		overflow: hidden;
		margin-bottom: 8px;
	}

	.confidence-fill {
		height: 100%;
		background: var(--success);
		transition: width 0.3s;
		width: 0%;
	}

	.result-confidence span {
		font-size: 14px;
		color: var(--text-muted);
	}

	.all-predictions {
		margin-top: 24px;
		padding-top: 24px;
		border-top: 1px solid var(--border);
	}

	.prediction-item {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 8px 0;
		font-size: 14px;
	}

	.prediction-item .name {
		color: var(--text);
	}

	.prediction-item .score {
		color: var(--text-muted);
	}

	@media (max-width: 768px) {
		.test-container {
			grid-template-columns: 1fr;
		}
	}
</style>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>

<script is:inline>
	let uploadedDataset = {};
	let trainedModel = null;
	let classNames = [];

	const uploadZone = document.getElementById('uploadZone');
	const fileInput = document.getElementById('fileInput');
	const datasetSummary = document.getElementById('datasetSummary');
	const startTrainBtn = document.getElementById('startTrainBtn');

	// Click to upload
	uploadZone.addEventListener('click', () => fileInput.click());

	// File input change
	fileInput.addEventListener('change', (e) => {
		const files = Array.from(e.target.files || []);
		processFiles(files);
	});

	// Drag & drop support
	uploadZone.addEventListener('dragover', (e) => {
		e.preventDefault();
		e.stopPropagation();
		uploadZone.classList.add('drag-over');
	});

	uploadZone.addEventListener('dragleave', (e) => {
		e.preventDefault();
		e.stopPropagation();
		uploadZone.classList.remove('drag-over');
	});

	uploadZone.addEventListener('drop', async (e) => {
		e.preventDefault();
		e.stopPropagation();
		uploadZone.classList.remove('drag-over');

		const items = e.dataTransfer.items;
		const files = [];

		// Process dropped items (supports folders)
		for (let i = 0; i < items.length; i++) {
			const item = items[i].webkitGetAsEntry();
			if (item) {
				await traverseFileTree(item, files);
			}
		}

		if (files.length > 0) {
			processFiles(files);
		}
	});

	// Traverse folder structure
	async function traverseFileTree(item, files, path = '') {
		return new Promise((resolve) => {
			if (item.isFile) {
				item.file((file) => {
					if (file.type.startsWith('image/')) {
						file.folderPath = path;
						files.push(file);
					}
					resolve();
				});
			} else if (item.isDirectory) {
				const dirReader = item.createReader();
				dirReader.readEntries(async (entries) => {
					for (const entry of entries) {
						await traverseFileTree(entry, files, path + item.name + '/');
					}
					resolve();
				});
			}
		});
	}

	// Process files and auto-label from folder structure
	function processFiles(files) {
		uploadedDataset = {};

		files.forEach(file => {
			let className = 'unlabeled';
			
			// Try to extract class from folder path
			if (file.folderPath) {
				const parts = file.folderPath.split('/').filter(p => p);
				if (parts.length > 0) {
					className = parts[parts.length - 1];
				}
			}

			if (!uploadedDataset[className]) {
				uploadedDataset[className] = [];
			}
			uploadedDataset[className].push(file);
		});

		const classes = Object.keys(uploadedDataset);
		const totalImages = Object.values(uploadedDataset).reduce((sum, imgs) => sum + imgs.length, 0);

		if (classes.length >= 1 && totalImages > 0) {
			classNames = classes;
			document.getElementById('totalImages').textContent = totalImages;
			document.getElementById('totalClasses').textContent = classes.length;
			
			const classTags = document.getElementById('classTags');
			classTags.innerHTML = classes
				.map(name => `<div class="class-tag"><strong>${name}</strong>${uploadedDataset[name].length} images</div>`)
				.join('');

			datasetSummary.style.display = 'block';
		}
	}

	// Training
	startTrainBtn.addEventListener('click', async () => {
		document.getElementById('trainSection').style.display = 'block';
		setTimeout(() => {
			document.getElementById('trainSection').scrollIntoView({ behavior: 'smooth' });
		}, 100);

		const xs = [];
		const ys = [];

		// Load all images
		for (let i = 0; i < classNames.length; i++) {
			const className = classNames[i];
			const images = uploadedDataset[className];

			for (const file of images) {
				const img = await loadImage(file);
				xs.push(img);
				ys.push(i);
			}
		}

		// Create model
		const model = tf.sequential({
			layers: [
				tf.layers.flatten({ inputShape: [224, 224, 3] }),
				tf.layers.dense({ units: 128, activation: 'relu' }),
				tf.layers.dropout({ rate: 0.2 }),
				tf.layers.dense({ units: classNames.length, activation: 'softmax' })
			]
		});

		model.compile({
			optimizer: 'adam',
			loss: 'sparseCategoricalCrossentropy',
			metrics: ['accuracy']
		});

		const xsTensor = tf.stack(xs);
		const ysTensor = tf.tensor1d(ys, 'int32');

		// Train
		await model.fit(xsTensor, ysTensor, {
			epochs: 10,
			callbacks: {
				onEpochEnd: (epoch, logs) => {
					const progress = ((epoch + 1) / 10) * 100;
					document.getElementById('progressFill').style.width = progress + '%';
					document.getElementById('progressPercent').textContent = Math.round(progress) + '%';
					document.getElementById('progressText').textContent = `Epoch ${epoch + 1}/10 - Loss: ${logs.loss.toFixed(4)}`;
				}
			}
		});

		trainedModel = model;
		document.getElementById('progressText').textContent = 'Training complete!';
		document.getElementById('testSection').style.display = 'block';
		
		setTimeout(() => {
			document.getElementById('testSection').scrollIntoView({ behavior: 'smooth' });
		}, 500);

		xsTensor.dispose();
		ysTensor.dispose();
	});

	async function loadImage(file) {
		return new Promise((resolve) => {
			const reader = new FileReader();
			reader.onload = (e) => {
				const img = new Image();
				img.onload = () => {
					const tensor = tf.browser.fromPixels(img)
						.resizeBilinear([224, 224])
						.toFloat()
						.div(255.0);
					resolve(tensor);
				};
				img.src = e.target.result;
			};
			reader.readAsDataURL(file);
		});
	}

	// Testing
	const testUpload = document.getElementById('testUpload');
	const testInput = document.getElementById('testInput');
	const testResult = document.getElementById('testResult');

	testUpload.addEventListener('click', () => testInput.click());

	testInput.addEventListener('change', async (e) => {
		const file = e.target.files[0];
		if (file && trainedModel) {
			const reader = new FileReader();
			reader.onload = async (e) => {
				const img = document.getElementById('testImage');
				img.src = e.target.result;
				
				const testImg = new Image();
				testImg.onload = async () => {
					const tensor = tf.browser.fromPixels(testImg)
						.resizeBilinear([224, 224])
						.toFloat()
						.div(255.0)
						.expandDims(0);

					const predictions = await trainedModel.predict(tensor);
					const probabilities = await predictions.data();
					const maxIndex = probabilities.indexOf(Math.max(...Array.from(probabilities)));
					const confidence = probabilities[maxIndex] * 100;

					document.getElementById('resultClass').textContent = classNames[maxIndex];
					document.getElementById('confidenceFill').style.width = confidence + '%';
					document.getElementById('confidenceText').textContent = `${confidence.toFixed(1)}% confidence`;

					const allPreds = document.getElementById('allPredictions');
					allPreds.innerHTML = '<h4 style="margin-bottom: 12px; font-size: 14px; color: var(--text-muted);">All Predictions:</h4>' +
						classNames
							.map((name, i) => `
								<div class="prediction-item">
									<span class="name">${name}</span>
									<span class="score">${(probabilities[i] * 100).toFixed(1)}%</span>
								</div>
							`)
							.join('');

					testResult.style.display = 'block';

					tensor.dispose();
					predictions.dispose();
				};
				testImg.src = e.target.result;
			};
			reader.readAsDataURL(file);
		}
	});
</script>
